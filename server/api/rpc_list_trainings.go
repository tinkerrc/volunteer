package api

import (
	"context"
	"errors"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/google/uuid"
	"github.com/tinkerrc/volunteer/ent"
	"github.com/tinkerrc/volunteer/ent/cert"
	"github.com/tinkerrc/volunteer/ent/training"
	"github.com/tinkerrc/volunteer/ent/volunteer"
	apiv1 "github.com/tinkerrc/volunteer/proto/api/v1" // generated by protoc-gen-go
)

func (s *APIServer) ListTrainings(
	ctx context.Context,
	req *connect.Request[apiv1.ListTrainingsRequest],
) (*connect.Response[apiv1.ListTrainingsResponse], error) {
	err := s.ensureAdmin(ctx)
	if err != nil {
		return nil, connect.NewError(connect.CodePermissionDenied, errors.New("unauthorized"))
	}
	m := req.Msg
	if m.PageSize > 50 {
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("page size too large"))
	}
	query := s.Db.Training.Query().WithCert().WithVolunteer().Order(ent.Desc(training.FieldStartDate))
	if m.CertId != nil {
		cid, err := uuid.Parse(*m.CertId)
		if err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid cert id"))
		}
		query = query.Where(training.HasCertWith(cert.ID(cid)))
	}
	if m.VolunteerId != nil {
		vid, err := uuid.Parse(*m.VolunteerId)
		if err != nil {
			return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid volunteer id"))
		}
		query = query.Where(training.HasVolunteerWith(volunteer.ID(vid)))
	}
	if m.IsCertified != nil {
		query = query.Where(training.IsCertified(*m.IsCertified))
	}
	ts, err := query.Limit(int(m.PageSize)).Offset(int(m.PageSize * m.PageNumber)).All(ctx)
	if err != nil {
		return nil, connect.NewError(connect.CodeNotFound, errors.New("could not find such trainints"))
	}
	tProtos := make([]*apiv1.Training, len(ts))
	for idx, t := range ts {
		tProtos[idx] = &apiv1.Training{
			Id:          t.ID.String(),
			VolunteerId: t.Edges.Volunteer.ID.String(),
			CertId:      t.Edges.Cert.ID.String(),
			StartDate:   timestamppb.New(t.StartDate),
			IsCertified: t.IsCertified,
		}
		if t.EndDate != nil {
			tProtos[idx].EndDate = timestamppb.New(*t.EndDate)
		}
	}
	res := connect.NewResponse(&apiv1.ListTrainingsResponse{
		Trainings: tProtos,
	})
	return res, nil
}
